<!--
  - CatLab Drinks - Simple bar automation system
  - Copyright (C) 2019 Thijs Van der Schaeghe
  - CatLab Interactive bvba, Gent, Belgium
  - http://www.catlab.eu/
  -
  - This program is free software; you can redistribute it and/or modify
  - it under the terms of the GNU General Public License as published by
  - the Free Software Foundation; either version 3 of the License, or
  - (at your option) any later version.
  -
  - This program is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU General Public License along
  - with this program; if not, write to the Free Software Foundation, Inc.,
  - 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  -->

<template>

    <b-container fluid>

        <b-row>
            <b-col cols="12" id="attendees-page">

                <div class="text-center" v-if="!loaded">
                    <b-spinner :label="$t('Loading data')" />
                </div>

                <div v-if="loaded">

                    <b-link class="btn btn-success mb-3" :to="{ name: 'checkIn', params: { id: this.eventId } }" :title="$t('Check-In')">
                        <span>ðŸ›‚</span>
                        {{ $t('Check-In') }}
                    </b-link>

                    <h2>Attendees: {{ event.name }}</h2>

                    <div class="alert alert-info">
                        <p>
                            <strong>About attendees:</strong>
                            Attendees link card aliases (secret tokens) to personal information such as name and email.
                            This allows NFC card holders to place remote orders using their alias without physically scanning their card.
                            The alias must remain secret, as it grants access to spend credit from the linked card.
                        </p>
                        <p>
                            To actually link a card to an alias, the organiser must <strong>check in</strong> the attendee
                            using the Check-In module. Only after check-in is the alias linked to the NFC card.
                            Aliases expire after 24 hours.
                        </p>
                        <p class="mb-0">
                            Aliases can be generated by external tools such as <a href="https://www.quizwitz.com" target="_blank" rel="noopener noreferrer">QuizWitz.com</a>.
                            You can paste tab-separated or colon-separated data directly into the spreadsheet below.
                        </p>
                    </div>

                    <spreadsheet
                        :columns="columns"
                        :rows="rows"
                        :saving="saving"
                        :saved="saved"
                        @save="saveChanges"
                        @reset="refresh"
                        @delete-all="deleteAll"
                    />

                </div>

            </b-col>
        </b-row>

    </b-container>

</template>

<script>

    import {EventService} from "../services/EventService";
    import Spreadsheet from "../components/Spreadsheet.vue";

    const COLUMNS = [
        { key: 'alias', label: 'Alias' },
        { key: 'name', label: 'Name' },
        { key: 'email', label: 'Email' }
    ];
    const EMPTY_ROWS = 5;
    let nextKey = 0;

    function createEmptyRow() {
        return { _key: nextKey++, _id: null, _dirty: false, _deleted: false, alias: '', name: '', email: '' };
    }

    export default {

        components: {
            'spreadsheet': Spreadsheet
        },

        mounted() {

            this.service = new EventService(window.ORGANISATION_ID); // hacky hacky

            this.eventId = this.$route.params.id;
            this.refresh();

        },

        watch: {
            '$route' (to, from) {
                // react to route changes...
                this.eventId = to.params.id;
                this.refresh();
            }
        },

        data() {
            return {
                loaded: false,
                eventId: null,
                event: null,
                rows: [],
                columns: COLUMNS,
                saving: false,
                saved: false
            }
        },

        methods: {

            async refresh() {
                this.loaded = false;

                if (this.eventId) {
                    this.event = await this.service.get(this.eventId);

                    // Load existing attendees
                    const response = await this.service.getAttendees(this.event.id);
                    const attendees = response.items || [];

                    this.rows = attendees.map(a => ({
                        _key: nextKey++,
                        _id: a.id,
                        _dirty: false,
                        _deleted: false,
                        alias: a.alias || '',
                        name: a.name || '',
                        email: a.email || ''
                    }));

                    // Add empty rows at the bottom
                    for (let i = 0; i < EMPTY_ROWS; i++) {
                        this.rows.push(createEmptyRow());
                    }

                    this.loaded = true;
                }
            },

            isRowEmpty(row) {
                return !row.alias && !row.name && !row.email;
            },

            async saveChanges() {
                this.saving = true;
                this.saved = false;

                try {
                    // Collect rows to create
                    const toCreate = [];
                    const toDeleteIds = [];
                    const updatePromises = [];

                    for (const row of this.rows) {
                        if (row._deleted && row._id) {
                            toDeleteIds.push(row._id);
                        } else if (row._id && row._dirty) {
                            updatePromises.push(
                                this.service.updateAttendee(this.event.id, row._id, {
                                    alias: row.alias,
                                    name: row.name,
                                    email: row.email
                                })
                            );
                        } else if (!row._id && !row._deleted && row._dirty && !this.isRowEmpty(row)) {
                            toCreate.push({
                                alias: row.alias,
                                name: row.name,
                                email: row.email
                            });
                        }
                    }

                    const promises = [...updatePromises];

                    // Bulk create
                    if (toCreate.length > 0) {
                        promises.push(this.service.bulkCreateAttendees(this.event.id, toCreate));
                    }

                    // Bulk delete
                    if (toDeleteIds.length > 0) {
                        promises.push(this.service.bulkDeleteAttendees(this.event.id, toDeleteIds));
                    }

                    await Promise.all(promises);

                    // Reload data
                    await this.refresh();

                    this.saved = true;
                    setTimeout(() => { this.saved = false; }, 2500);
                } catch (err) {
                    console.error('Error saving attendees:', err);
                } finally {
                    this.saving = false;
                }
            },

            async deleteAll() {
                this.saving = true;
                this.saved = false;

                try {
                    const allIds = this.rows
                        .filter(row => row._id)
                        .map(row => row._id);

                    if (allIds.length > 0) {
                        await this.service.bulkDeleteAttendees(this.event.id, allIds);
                    }

                    await this.refresh();

                    this.saved = true;
                    setTimeout(() => { this.saved = false; }, 2500);
                } catch (err) {
                    console.error('Error deleting all attendees:', err);
                } finally {
                    this.saving = false;
                }
            }
        }
    }
</script>
