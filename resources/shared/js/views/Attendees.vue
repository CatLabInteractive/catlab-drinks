<!--
  - CatLab Drinks - Simple bar automation system
  - Copyright (C) 2019 Thijs Van der Schaeghe
  - CatLab Interactive bvba, Gent, Belgium
  - http://www.catlab.eu/
  -
  - This program is free software; you can redistribute it and/or modify
  - it under the terms of the GNU General Public License as published by
  - the Free Software Foundation; either version 3 of the License, or
  - (at your option) any later version.
  -
  - This program is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU General Public License along
  - with this program; if not, write to the Free Software Foundation, Inc.,
  - 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  -->

<template>

    <b-container fluid>

        <b-row>
            <b-col cols="12" id="attendees-page">

                <div class="text-center" v-if="!loaded">
                    <b-spinner :label="$t('Loading data')" />
                </div>

                <div v-if="loaded">

                    <b-link class="btn btn-success mb-3" :to="{ name: 'checkIn', params: { id: this.eventId } }" :title="$t('Check-In')">
                        <span>ðŸ›‚</span>
                        {{ $t('Check-In') }}
                    </b-link>

                    <h2>Attendees: {{ event.name }}</h2>

                    <div class="alert alert-info">
                        <p>
                            <strong>About attendees:</strong>
                            Attendees link card aliases (secret tokens) to personal information such as name and email.
                            This allows NFC card holders to place remote orders using their alias without physically scanning their card.
                            The alias must remain secret, as it grants access to spend credit from the linked card.
                        </p>
                        <p>
                            To actually link a card to an alias, the organiser must <strong>check in</strong> the attendee
                            using the Check-In module. Only after check-in is the alias linked to the NFC card.
                            Aliases expire after 24 hours.
                        </p>
                        <p class="mb-0">
                            Aliases can be generated by external tools such as <a href="https://www.quizwitz.com" target="_blank" rel="noopener noreferrer">QuizWitz.com</a>.
                            You can paste tab-separated data directly into the spreadsheet below.
                        </p>
                    </div>

                    <div class="attendees-spreadsheet mb-3">
                        <table class="table table-bordered table-sm attendees-table" @keydown="handleKeydown">
                            <thead>
                                <tr>
                                    <th style="width: 50px">#</th>
                                    <th>Alias</th>
                                    <th>Name</th>
                                    <th>Email</th>
                                    <th style="width: 60px"></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="(row, rowIndex) in rows" :key="row._key" :class="{ 'table-warning': row._dirty, 'table-danger': row._deleted }">
                                    <td class="row-number">{{ rowIndex + 1 }}</td>
                                    <td v-for="(col, colIndex) in columns" :key="col"
                                        :class="{ 'active-cell': activeRow === rowIndex && activeCol === colIndex }"
                                        @click="activateCell(rowIndex, colIndex)">
                                        <input
                                            :ref="'cell-' + rowIndex + '-' + colIndex"
                                            type="text"
                                            class="cell-input"
                                            v-model="row[col]"
                                            @focus="activateCell(rowIndex, colIndex)"
                                            @input="markDirty(rowIndex)"
                                            @paste="handlePaste($event, rowIndex, colIndex)"
                                            :disabled="row._deleted"
                                        />
                                    </td>
                                    <td class="text-center">
                                        <button v-if="!row._deleted && (row._id || row.alias || row.name || row.email)"
                                            class="btn btn-sm btn-outline-danger"
                                            @click="deleteRow(rowIndex)"
                                            title="Delete row">âœ•</button>
                                        <button v-if="row._deleted"
                                            class="btn btn-sm btn-outline-secondary"
                                            @click="undeleteRow(rowIndex)"
                                            title="Undo delete">â†©</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="mb-3">
                        <b-btn variant="success" @click="saveChanges" :disabled="saving">
                            {{ saving ? 'Saving...' : 'Save changes' }}
                        </b-btn>
                        <b-btn variant="light" @click="refresh()">Reset</b-btn>
                        <b-btn variant="outline-secondary" @click="addRows(5)">Add rows</b-btn>

                        <b-alert v-if="saved" variant="success" show class="d-inline-block ml-2 mb-0 py-1 px-2">Saved</b-alert>
                    </div>

                </div>

            </b-col>
        </b-row>

    </b-container>

</template>

<script>

    import {EventService} from "../services/EventService";

    const COLUMNS = ['alias', 'name', 'email'];
    const EMPTY_ROWS = 5;
    let nextKey = 0;

    function createEmptyRow() {
        return { _key: nextKey++, _id: null, _dirty: false, _deleted: false, alias: '', name: '', email: '' };
    }

    export default {
        mounted() {

            this.service = new EventService(window.ORGANISATION_ID); // hacky hacky

            this.eventId = this.$route.params.id;
            this.refresh();

        },

        watch: {
            '$route' (to, from) {
                // react to route changes...
                this.eventId = to.params.id;
                this.refresh();
            }
        },

        data() {
            return {
                loaded: false,
                eventId: null,
                event: null,
                rows: [],
                columns: COLUMNS,
                activeRow: -1,
                activeCol: -1,
                saving: false,
                saved: false
            }
        },

        methods: {

            async refresh() {
                this.loaded = false;

                if (this.eventId) {
                    this.event = await this.service.get(this.eventId);

                    // Load existing attendees
                    const response = await this.service.getAttendees(this.event.id);
                    const attendees = response.items || [];

                    this.rows = attendees.map(a => ({
                        _key: nextKey++,
                        _id: a.id,
                        _dirty: false,
                        _deleted: false,
                        alias: a.alias || '',
                        name: a.name || '',
                        email: a.email || ''
                    }));

                    // Add empty rows at the bottom
                    for (let i = 0; i < EMPTY_ROWS; i++) {
                        this.rows.push(createEmptyRow());
                    }

                    this.loaded = true;
                }
            },

            activateCell(rowIndex, colIndex) {
                this.activeRow = rowIndex;
                this.activeCol = colIndex;
                this.$nextTick(() => {
                    const ref = this.$refs['cell-' + rowIndex + '-' + colIndex];
                    if (ref) {
                        const el = Array.isArray(ref) ? ref[0] : ref;
                        if (el && el.focus) el.focus();
                    }
                });
            },

            handleKeydown(e) {
                if (this.activeRow < 0 || this.activeCol < 0) return;

                let newRow = this.activeRow;
                let newCol = this.activeCol;

                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    newRow = Math.max(0, this.activeRow - 1);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    newRow = Math.min(this.rows.length - 1, this.activeRow + 1);
                } else if (e.key === 'Tab' && !e.shiftKey) {
                    e.preventDefault();
                    if (this.activeCol < COLUMNS.length - 1) {
                        newCol = this.activeCol + 1;
                    } else if (this.activeRow < this.rows.length - 1) {
                        newCol = 0;
                        newRow = this.activeRow + 1;
                    }
                    // Add new rows when tabbing past the last row
                    if (newRow === this.rows.length - 1 && newCol === COLUMNS.length - 1) {
                        this.addRows(1);
                    }
                } else if (e.key === 'Tab' && e.shiftKey) {
                    e.preventDefault();
                    if (this.activeCol > 0) {
                        newCol = this.activeCol - 1;
                    } else if (this.activeRow > 0) {
                        newCol = COLUMNS.length - 1;
                        newRow = this.activeRow - 1;
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    newRow = Math.min(this.rows.length - 1, this.activeRow + 1);
                    if (newRow === this.rows.length - 1) {
                        this.addRows(1);
                    }
                } else {
                    return;
                }

                this.activateCell(newRow, newCol);
            },

            handlePaste(e, rowIndex, colIndex) {
                const clipboardData = e.clipboardData || window.clipboardData;
                if (!clipboardData) return;

                const text = clipboardData.getData('text');
                if (!text) return;

                // Check if this is multi-cell data (contains tabs or newlines)
                if (text.indexOf('\t') === -1 && text.indexOf('\n') === -1) {
                    return; // Single value, let default paste handle it
                }

                e.preventDefault();

                const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');

                for (let i = 0; i < lines.length; i++) {
                    const targetRow = rowIndex + i;

                    // Add new rows if needed
                    while (targetRow >= this.rows.length) {
                        this.rows.push(createEmptyRow());
                    }

                    const cells = lines[i].split('\t');
                    for (let j = 0; j < cells.length; j++) {
                        const targetCol = colIndex + j;
                        if (targetCol < COLUMNS.length) {
                            this.rows[targetRow][COLUMNS[targetCol]] = cells[j].trim();
                        }
                    }
                    this.markDirty(targetRow);
                }

                // Ensure there are always empty rows at the bottom
                this.ensureEmptyRows();
            },

            markDirty(rowIndex) {
                this.rows[rowIndex]._dirty = true;
            },

            deleteRow(rowIndex) {
                const row = this.rows[rowIndex];
                if (row._id) {
                    // Existing attendee: mark for deletion
                    row._deleted = true;
                } else {
                    // New row: just remove it
                    this.rows.splice(rowIndex, 1);
                    this.ensureEmptyRows();
                }
            },

            undeleteRow(rowIndex) {
                this.rows[rowIndex]._deleted = false;
            },

            addRows(count) {
                for (let i = 0; i < count; i++) {
                    this.rows.push(createEmptyRow());
                }
            },

            ensureEmptyRows() {
                // Make sure there are at least EMPTY_ROWS empty rows at the bottom
                let emptyCount = 0;
                for (let i = this.rows.length - 1; i >= 0; i--) {
                    const row = this.rows[i];
                    if (!row._id && !row.alias && !row.name && !row.email && !row._deleted) {
                        emptyCount++;
                    } else {
                        break;
                    }
                }
                while (emptyCount < EMPTY_ROWS) {
                    this.rows.push(createEmptyRow());
                    emptyCount++;
                }
            },

            isRowEmpty(row) {
                return !row.alias && !row.name && !row.email;
            },

            async saveChanges() {
                this.saving = true;
                this.saved = false;

                try {
                    const promises = [];

                    for (const row of this.rows) {
                        if (row._deleted && row._id) {
                            // Delete existing attendee
                            promises.push(
                                this.service.deleteAttendee(this.event.id, row._id)
                            );
                        } else if (row._id && row._dirty) {
                            // Update existing attendee
                            promises.push(
                                this.service.updateAttendee(this.event.id, row._id, {
                                    alias: row.alias,
                                    name: row.name,
                                    email: row.email
                                })
                            );
                        } else if (!row._id && !row._deleted && row._dirty && !this.isRowEmpty(row)) {
                            // Create new attendee
                            promises.push(
                                this.service.createAttendee(this.event.id, {
                                    alias: row.alias,
                                    name: row.name,
                                    email: row.email
                                })
                            );
                        }
                    }

                    await Promise.all(promises);

                    // Reload data
                    await this.refresh();

                    this.saved = true;
                    setTimeout(() => { this.saved = false; }, 2500);
                } catch (err) {
                    console.error('Error saving attendees:', err);
                } finally {
                    this.saving = false;
                }
            }
        }
    }
</script>

<style scoped>
    .attendees-table {
        border-collapse: collapse;
    }
    .attendees-table th {
        background-color: #f8f9fa;
        position: sticky;
        top: 0;
        z-index: 1;
    }
    .attendees-table td {
        padding: 0 !important;
        vertical-align: middle;
    }
    .attendees-table td.row-number {
        padding: 4px 8px !important;
        text-align: center;
        color: #999;
        background-color: #f8f9fa;
        font-size: 0.85em;
    }
    .cell-input {
        width: 100%;
        border: none;
        outline: none;
        padding: 4px 8px;
        background: transparent;
        font-size: 0.9em;
    }
    .cell-input:focus {
        background-color: #fff;
        box-shadow: inset 0 0 0 2px #80bdff;
    }
    .cell-input:disabled {
        color: #999;
        text-decoration: line-through;
    }
    .active-cell {
        background-color: #e8f0fe;
    }
    .attendees-table .btn-sm {
        padding: 0 6px;
        line-height: 1.5;
    }
</style>
